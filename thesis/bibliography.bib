@inproceedings{10.1145_3102980.3103006,
    author = {Balasubramanian, Abhiram and Baranowski, Marek S. and Burtsev, Anton and Panda, Aurojit and Rakamari\'{c}, Zvonimir and Ryzhyk, Leonid},
    title = {System Programming in Rust: Beyond Safety},
    year = {2017},
    isbn = {9781450350686},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3102980.3103006},
    doi = {10.1145/3102980.3103006},
    abstract = {Rust is a new system programming language that offers a practical and safe alternative to C. Rust is unique in that it enforces safety without runtime overhead, most importantly, without the overhead of garbage collection. While zero-cost safety is remarkable on its own, we argue that the superpowers of Rust go beyond safety. In particular, Rust's linear type system enables capabilities that cannot be implemented efficiently in traditional languages, both safe and unsafe, and that dramatically improve security and reliability of system software. We show three examples of such capabilities: zero-copy software fault isolation, efficient static information flow analysis, and automatic checkpointing. While these capabilities have been in the spotlight of systems research for a long time, their practical use is hindered by high cost and complexity. We argue that with the adoption of Rust these mechanisms will become commoditized.},
    booktitle = {Proceedings of the 16th Workshop on Hot Topics in Operating Systems},
    pages = {156-161},
    numpages = {6},
    location = {Whistler, BC, Canada},
    series = {HotOS '17}
}

@article{jung2020safe,
  title={Safe systems programming in Rust: The promise and the challenge},
  author={Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  journal={Communications of the ACM},
  volume={64},
  number={4},
  pages={144--152},
  year={2020}
}

@article{10.1145_3360573,
author = {Astrauskas, Vytautas and M\"{u}ller, Peter and Poli, Federico and Summers, Alexander J.},
title = {Leveraging rust types for modular specification and verification},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360573},
doi = {10.1145/3360573},
abstract = {Rust's type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Ensuring correctness properties beyond memory safety, for instance, the guaranteed absence of assertion failures or more-general functional correctness, requires static program verification. For traditional system programming languages, formal verification is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to the more-widespread verification of system software.  In this paper, we present a novel verification technique that leverages Rust's type system to greatly simplify the specification and verification of system software written in Rust. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. To verify correctness properties beyond memory safety, users can annotate Rust programs with specifications at the abstraction level of Rust expressions; our technique weaves them into the core proof to verify modularly whether these specifications hold. Crucially, our proofs are constructed and checked automatically without exposing the underlying formal logic, allowing users to work exclusively at the level of abstraction of the programming language. As such, our work enables a new kind of verification tool, with the potential to impact a wide audience and allow the Rust community to benefit from state-of-the-art verification techniques. We have implemented our techniques for a subset of Rust; our evaluation on several thousand functions from widely-used Rust crates demonstrates its effectiveness.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {147},
numpages = {30},
keywords = {type systems, heap-manipulating programs, concurrency, Rust}
}

@phdthesis{방인영2024study,
  title={A Study of Memory Safety in Unsafe and Safe Languages},
  author={방인영},
  year={2024},
  school={서울대학교 대학원}
}

// paper to doctorate thesis above
@inproceedings {287352,
author = {Inyoung Bang and Martin Kayondo and HyunGon Moon and Yunheung Paek},
title = {{TRust}: A Compilation Framework for In-process Isolation to Protect Safe Rust against Untrusted Code},
booktitle = {32nd USENIX Security Symposium (USENIX Security 23)},
year = {2023},
isbn = {978-1-939133-37-3},
address = {Anaheim, CA},
pages = {6947--6964},
url = {https://www.usenix.org/conference/usenixsecurity23/presentation/bang},
publisher = {USENIX Association},
month = aug
}

@online{cwe-top25-2025,
  title        = {2025 CWE Top 25 Most Dangerous Software Weaknesses},
  author       = {{The MITRE Corporation}},
  year         = {2025},
  month        = dec,
  url          = {https://cwe.mitre.org/top25/archive/2025/2025_cwe_top25.html},
  urldate      = {2026-02-13},
  note         = {Page last updated December 15, 2025},
  x-found-via  = {방인영2024study},
}

@misc{bugden2022rustprogramminglanguagesafety,
      title={Rust: The Programming Language for Safety and Performance}, 
      author={William Bugden and Ayman Alahmar},
      year={2022},
      eprint={2206.05503},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2206.05503}, 
}

@article{10.1145_3428204,
author = {Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and M\"{u}ller, Peter and Summers, Alexander J.},
title = {How do programmers use unsafe rust?},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428204},
doi = {10.1145/3428204},
abstract = {Rust’s ownership type system enforces a strict discipline on how memory locations are accessed and shared. This discipline allows the compiler to statically prevent memory errors, data races, inadvertent side effects through aliasing, and other errors that frequently occur in conventional imperative programs. However, the restrictions imposed by Rust’s type system make it difficult or impossible to implement certain designs, such as data structures that require aliasing (e.g. doubly-linked lists and shared caches). To work around this limitation, Rust allows code blocks to be declared as unsafe and thereby exempted from certain restrictions of the type system, for instance, to manipulate C-style raw pointers. Ensuring the safety of unsafe code is the responsibility of the programmer. However, an important assumption of the Rust language, which we dub the Rust hypothesis, is that programmers use Rust by following three main principles: use unsafe code sparingly, make it easy to review, and hide it behind a safe abstraction such that client code can be written in safe Rust. Understanding how Rust programmers use unsafe code and, in particular, whether the Rust hypothesis holds is essential for Rust developers and testers, language and library designers, as well as tool developers. This paper studies empirically how unsafe code is used in practice by analysing a large corpus of Rust projects to assess the validity of the Rust hypothesis and to classify the purpose of unsafe code. We identify queries that can be answered by automatically inspecting the program’s source code, its intermediate representation MIR, as well as type information provided by the Rust compiler; we complement the results by manual code inspection. Our study supports the Rust hypothesis partially: While most unsafe code is simple and well-encapsulated, unsafe features are used extensively, especially for interoperability with other languages.},
journal = {Proc. ACM Program. Lang.},
month = nov,
articleno = {136},
numpages = {27},
keywords = {unsafe code, empirical study, Rust hypothesis, Rust}
}

@Inbook{Oikawa2023,
author="Oikawa, Shuichi",
editor="Lee, Roger",
title="The Experience of Developing a FAT File System Module in the Rust Programming Language",
bookTitle="Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing",
year="2023",
publisher="Springer International Publishing",
address="Cham",
pages="45--58",
abstract="The Linux kernel is a heart of the operating system, and provides the abstractions of hardware resources and manages them to be used efficiently and effectively by application programs. The operating system kernel has been programmed by the C programming language. It has been a major system programming language for a long time due to its efficiency and simplicity. Recently, there is a move towards introducing the Rust programming language to the Linux kernel for the type and memory safety; thus, it is meaningful to explore the possibility of utilizing Rust to program Linux kernel modules. This paper describes the experience of developing the FAT file system as a kernel module in Rust employing Rust for Linux as a basis of the development. We performed the experiments to measure its execution costs, and found that its performance is comparable with the original FAT file system written in C.",
isbn="978-3-031-19604-1",
doi="10.1007/978-3-031-19604-1_4",
url="https://doi.org/10.1007/978-3-031-19604-1_4"
}

@INPROCEEDINGS{10592287,
  author={Seidel, Lukas and Beier, Julian},
  booktitle={2024 Security for Space Systems (3S)}, 
  title={Bringing Rust to Safety-Critical Systems in Space}, 
  year={2024},
  volume={},
  number={},
  pages={1-8},
  keywords={Industries;Protocols;Metals;Telescopes;Programming;Robustness;Aerospace safety},
  doi={10.23919/3S60530.2024.10592287}}
